// userspace.cpp
#include <iostream>
#include <string>
#include <vector>
#include <csignal>
#include <chrono>

// Libbpf headers
#include <bpf/libbpf.h>
#include <pwd.h>
#include <map>
// Include the skeleton generated by bpftool
#include "exitsnoop.skel.h"
#include "exitsnoop.bpf.h"
#include "utils.h"

static volatile bool running = true;
// 全局变量，用于存储 UID 到用户名的映射
static std::map<uid_t, std::string> uid_to_username_map;

/**
 * @brief 解析 /etc/passwd 文件，填充 UID 到用户名的映射。
 * 使用 getpwent() 比手动解析文件更健壮、更安全。
 */
void populate_uid_map() {
    struct passwd *pw_entry;

    // setpwent() 将文件指针重置到 /etc/passwd 的开头
    setpwent();

    // getpwent() 在循环中依次读取每一行条目
    while ((pw_entry = getpwent()) != NULL) {
        // 将 UID 和用户名存入 map
        uid_to_username_map[pw_entry->pw_uid] = pw_entry->pw_name;
    }

    // endpwent() 关闭 /etc/passwd 文件
    endpwent();

    // std::cerr << "成功加载 " << uid_to_username_map.size() << " 个用户条目到内存。" << std::endl;
}
// Signal handler for graceful shutdown
void sig_handler(int signum) {
    // std::cout << "\nCaught signal, exiting..." << std::endl;
    running = false;
}

// Callback function for handling events from the ring buffer
int handle_event(void *ctx, void *data, size_t size) {
    const auto e = static_cast<const exitsnoop_event_t*>(data);

    std::string username = "N/A"; // 默认值

    // 从预加载的 map 中通过 UID 快速查找用户名
    auto it = uid_to_username_map.find(e->uid);
    if (it != uid_to_username_map.end()) {
        // 如果找到了，就使用 map 中的用户名
        username = it->second;
    } else {
        // 如果在 map 中没找到 (例如某些系统用户)，可以保留为 UID 字符串
        username = std::to_string(e->uid);
    }

    // 输出logfmt格式的数据
    std::cout << "timestamp=" << getTimestampMs()
              << " pid=" << e->pid
              << " ppid=" << e->ppid
              << " exit_code=" << e->exit_code
              << " duration_ms=" << std::chrono::duration_cast<std::chrono::milliseconds>(
                  std::chrono::nanoseconds(e->duration_ns)).count()
              << " comm=" << e->comm
              << " pcomm=" << e->pcomm
              << " user=" << username
              << std::endl;

    return 0;
}

int main(int argc, char **argv) {
    struct exitsnoop_bpf *skel;
    struct ring_buffer *rb = nullptr;
    int err;

    // Set up signal handlers for Ctrl+C
    signal(SIGINT, sig_handler);
    signal(SIGTERM, sig_handler);

    // 在程序开始时，只调用一次函数来填充映射
    populate_uid_map();

    // 1. Open BPF application
    skel = exitsnoop_bpf__open();
    if (!skel) {
        std::cerr << "Failed to open BPF skeleton" << std::endl;
        return 1;
    }

    // 2. Load & verify BPF programs
    err = exitsnoop_bpf__load(skel);
    if (err) {
        std::cerr << "Failed to load and verify BPF skeleton" << std::endl;
        goto cleanup;
    }

    // 3. Attach tracepoint handlers
    err = exitsnoop_bpf__attach(skel);
    if (err) {
        std::cerr << "Failed to attach BPF skeleton" << std::endl;
        goto cleanup;
    }

    // std::cout << "Successfully started! Please wait for process exit events..." << std::endl;
    // std::cout << "Run commands in another terminal (e.g., 'ls', 'sleep 1', 'echo hello') to generate events." << std::endl;
    // std::cout << "Press Ctrl+C to exit." << std::endl;

    // 4. Set up ring buffer polling
    rb = ring_buffer__new(bpf_map__fd(skel->maps.rb), handle_event, nullptr, nullptr);
    if (!rb) {
        err = -1;
        std::cerr << "Failed to create ring buffer" << std::endl;
        goto cleanup;
    }

    // 5. Main loop
    while (running) {
        // Poll for events, with a 100ms timeout.
        // The callback `handle_event` will be invoked for each received event.
        err = ring_buffer__poll(rb, 100 /* timeout, ms */);

        // `err` is the number of events consumed, or a negative error code.
        if (err < 0) {
            // Ctrl-C will cause -EINTR
            if (err == -EINTR) {
                err = 0;
                break;
            }
            std::cerr << "Error polling ring buffer: " << strerror(-err) << std::endl;
            break;
        }
    }

cleanup:
    // Clean up resources
    ring_buffer__free(rb);
    exitsnoop_bpf__destroy(skel);
    return -err;
}